object ChessGame {
    private var piecesBox: MutableMap<Square, ChessPiece>
    var turn = Player.WHITE
    private val hasMoved: MutableSet<Square>
    private var hasKingMoved = mutableMapOf<Player, Boolean>(Player.WHITE to false, Player.BLACK to false)
    private var hasRookMoved = mutableMapOf<Square, Boolean>()

    init {
        hasRookMoved[Square(0, 0)] = false
        hasRookMoved[Square(7, 0)] = false
        hasRookMoved[Square(0, 7)] = false
        hasRookMoved[Square(7, 7)] = false
        piecesBox = mutableMapOf()
        hasMoved = mutableSetOf()
        reset()
    }

    fun reset() {
        piecesBox.clear()
        turn = Player.WHITE

        // Setup initial pieces configuration
        // Add pawns
        for (i in 0 until 8) {
            piecesBox[Square(i, 1)] = ChessPiece(Player.WHITE, Chessman.PAWN, R.drawable.pawn_white)
            piecesBox[Square(i, 6)] = ChessPiece(Player.BLACK, Chessman.PAWN, R.drawable.pawn_black)
        }

        // Add rooks
        piecesBox[Square(0, 0)] = ChessPiece(Player.WHITE, Chessman.ROOK, R.drawable.rook_white)
        piecesBox[Square(7, 0)] = ChessPiece(Player.WHITE, Chessman.ROOK, R.drawable.rook_white)
        piecesBox[Square(0, 7)] = ChessPiece(Player.BLACK, Chessman.ROOK, R.drawable.rook_black)
        piecesBox[Square(7, 7)] = ChessPiece(Player.BLACK, Chessman.ROOK, R.drawable.rook_black)

        // Add knights
        piecesBox[Square(1, 0)] = ChessPiece(Player.WHITE, Chessman.KNIGHT, R.drawable.knight_white)
        piecesBox[Square(6, 0)] = ChessPiece(Player.WHITE, Chessman.KNIGHT, R.drawable.knight_white)
        piecesBox[Square(1, 7)] = ChessPiece(Player.BLACK, Chessman.KNIGHT, R.drawable.knight_black)
        piecesBox[Square(6, 7)] = ChessPiece(Player.BLACK, Chessman.KNIGHT, R.drawable.knight_black)

        // Add bishops
        piecesBox[Square(2, 0)] = ChessPiece(Player.WHITE, Chessman.BISHOP, R.drawable.bishop_white)
        piecesBox[Square(5, 0)] = ChessPiece(Player.WHITE, Chessman.BISHOP, R.drawable.bishop_white)
        piecesBox[Square(2, 7)] = ChessPiece(Player.BLACK, Chessman.BISHOP, R.drawable.bishop_black)
        piecesBox[Square(5, 7)] = ChessPiece(Player.BLACK, Chessman.BISHOP, R.drawable.bishop_black)

        // Add queens
        piecesBox[Square(3, 0)] = ChessPiece(Player.WHITE, Chessman.QUEEN, R.drawable.queen_white)
        piecesBox[Square(3, 7)] = ChessPiece(Player.BLACK, Chessman.QUEEN, R.drawable.queen_black)

        // Add kings
        piecesBox[Square(4, 0)] = ChessPiece(Player.WHITE, Chessman.KING, R.drawable.king_white)
        piecesBox[Square(4, 7)] = ChessPiece(Player.BLACK, Chessman.KING, R.drawable.king_black)
    }

    fun pieceAt(square: Square): ChessPiece? = piecesBox[square]

    fun movePiece(from: Square, to: Square) {
        val movingPiece = pieceAt(from) ?: return
        if (movingPiece.chessman == Chessman.KING && canCastle(from, to)) {
            performCastling(from, to)
        } else if (movingPiece.player == turn && canMove(from, to)) {
            piecesBox[to] = movingPiece
            piecesBox.remove(from)

            if (movingPiece.chessman == Chessman.KING) {
                hasKingMoved[movingPiece.player] = true
            } else if (movingPiece.chessman == Chessman.ROOK) {
                hasRookMoved[from] = true
            }

            turn = if (turn == Player.WHITE) Player.BLACK else Player.WHITE
        }
    }

    private fun canMove(from: Square, to: Square): Boolean {
        if (from == to) return false
        pieceAt(from)?.let { movingPiece ->
            // check if the move is valid for the piece
            val deltaCol = to.col - from.col
            val deltaRow = to.row - from.row
            val pieceAtDestination = pieceAt(to)
            if (pieceAtDestination?.player == movingPiece.player) return false

            when (movingPiece.chessman) {
                Chessman.PAWN -> {
                    val direction = if (movingPiece.player == Player.WHITE) 1 else -1
                    if (deltaCol == 0 && deltaRow == direction && pieceAtDestination == null) {
                        return true
                    }
                    if (deltaCol == 0 && deltaRow == 2 * direction && pieceAtDestination == null && (from.row == 1 || from.row == 6)) {
                        return true
                    }
                    if (abs(deltaCol) == 1 && deltaRow == direction && pieceAtDestination != null) {
                        return true
                    }
                }
                Chessman.ROOK -> {
                    if (deltaCol == 0 || deltaRow == 0) {
                        if (isPathClear(from, to)) return true
                    }
                    return from.col == to.col && isClearVerticallyBetween(from, to) ||
                            from.row == to.row && isClearHorizontallyBetween(from, to)

                }
                Chessman.KNIGHT -> {
                    if (abs(deltaCol * deltaRow) == 2) return true
                }
                Chessman.BISHOP -> {
                    if (abs(deltaCol) == abs(deltaRow)) {
                        if (isPathClear(from, to)) return true
                    }
                }
                Chessman.QUEEN -> {
                    if (deltaCol == 0 || deltaRow == 0 || abs(deltaCol) == abs(deltaRow)) {
                        if (isPathClear(from, to)) return true
                    }
                }
                Chessman.KING -> {
                    val movingPiece = pieceAt(from) ?: return false
                    if (!hasKingMoved[movingPiece.player]!! && from.row == to.row && deltaCol == 2) {
                        val rookCol = if (to.col > from.col) 7 else 0
                        val rookSquare = Square(rookCol, from.row)
                        val rookPiece = pieceAt(rookSquare)
                        if (rookPiece != null && rookPiece.chessman == Chessman.ROOK && !hasRookMoved[rookSquare]!!) {
                            val direction = if (rookCol == 7) 1 else -1
                            var pathClear = true
                            for (i in 1 until abs(to.col - from.col)) {
                                if (pieceAt(Square(from.col + i * direction, from.row)) != null) {
                                    pathClear = false
                                    break
                                }
                            }
                            if (pathClear) return true
                        }
                    }
                    return abs(deltaCol) <= 1 && abs(deltaRow) <= 1
                }
            }
        }
        return false
    }

    private fun canCastle(from: Square, to: Square): Boolean {
        val movingPiece = pieceAt(from) ?: return false
        if (movingPiece.chessman != Chessman.KING) return false

        // Check if the king or the rook has moved
        if (hasKingMoved[movingPiece.player] == true) return false

        val direction = if (to.col > from.col) 1 else -1
        val rookCol = if (direction == 1) 7 else 0
        val rookSquare = Square(rookCol, from.row)
        val rookPiece = pieceAt(rookSquare) ?: return false
        if (rookPiece.chessman != Chessman.ROOK || hasRookMoved[rookSquare] == true) return false

        // Check if the path between the king and rook is clear
        for (i in 1 until abs(to.col - from.col)) {
            if (pieceAt(Square(from.col + i * direction, from.row)) != null) {
                return false
            }
        }

        // Check if the king is in check or passes through a square that is under attack
        // For simplicity, this example does not implement the check detection function.
        // You would need to implement a function `isSquareUnderAttack` to complete this part.

        return true
    }

    private fun performCastling(from: Square, to: Square) {
        val direction = if (to.col > from.col) 1 else -1
        val newKingSquare = Square(from.col + 2 * direction, from.row)
        val newRookSquare = Square(from.col + direction, from.row)
        val rookSquare = Square(if (direction == 1) 7 else 0, from.row)

        piecesBox[newKingSquare] = piecesBox.remove(from)!!
        piecesBox[newRookSquare] = piecesBox.remove(rookSquare)!!

        hasMoved.add(newKingSquare)
        hasMoved.add(newRookSquare)

        hasKingMoved[piecesBox[newKingSquare]!!.player] = true
        hasRookMoved[rookSquare] = true

        turn = if (turn == Player.WHITE) Player.BLACK else Player.WHITE
    }

    private fun isPathClear(from: Square, to: Square): Boolean {
        val colStep = if (to.col - from.col > 0) 1 else if (to.col - from.col < 0) -1 else 0
        val rowStep = if (to.row - from.row > 0) 1 else if (to.row - from.row < 0) -1 else 0
        var currentCol = from.col + colStep
        var currentRow = from.row + rowStep
        while (currentCol != to.col || currentRow != to.row) {
            if (piecesBox[Square(currentCol, currentRow)] != null) return false
            currentCol += colStep
            currentRow += rowStep
        }
        return true
    }
}
